# 개념: B에서 거꾸로 A로 되돌아가며 연산을 반대로 적용한다.
# 이유: A에서 B로 가면 경우의 수가 많지만,
#       B에서 A로 줄이면 매번 선택이 거의 하나뿐이라 훨씬 빠르다.
#
# 규칙(거꾸로 적용하기):
#   1) B가 짝수라면 → 이전 단계에서 2를 곱했을 수 있으므로 B /= 2
#   2) B가 1로 끝난다면 → 이전 단계에서 "뒤에 1을 붙였을 수 있으므로" B = (B - 1) / 10
#   3) 위 두 가지 경우가 아니라면 → 더 이상 A로 줄일 수 없으므로 불가능

import sys

A, B = map(int, sys.stdin.readline().split())

def reverse_greedy(a, b):
    steps = 1  # 시작 숫자 B도 포함하므로 1부터 카운트
    while b > a:  # B가 A보다 클 때만 계속 줄이기 시도
        if b % 10 == 1:  # 맨 뒤가 1이라면
            b //= 10      # 1을 떼기 (거꾸로 보면, '1을 붙였던' 걸 되돌리는 것)
                        # 이미 나머지가 1이라는 것을 전제하에 10으로 나누므로 자연스럽게 소수는 나가떨어짐.
            steps += 1
        elif b % 2 == 0:  # 짝수라면
            b //= 2       # 2로 나누기 (거꾸로 보면, '2를 곱했던' 걸 되돌림)
            steps += 1
        else:
            # 짝수도 아니고, 끝이 1도 아니라면 A로 갈 방법이 없음
            return -1

    # while이 끝난 시점에서 b == a라면 성공
    return steps if b == a else -1

print(reverse_greedy(A, B))